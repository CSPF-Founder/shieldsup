import os
from datetime import datetime
from configparser import ConfigParser
from typing import OrderedDict
import zipfile
from xml.sax import saxutils
from math import ceil
from shutil import make_archive, rmtree, move
import statistics

from bson import ObjectId
from docx import Document
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
from docx.shared import Inches, RGBColor, Pt

from app import core, core_app
from app.db.connections.main_db import MainDatabase
from app.db.crud.target import CrudTarget
from app.enums.main import ScanStatus, SeverityIndex
from app.db.crud.scan_result import CrudScanResult
from app.db.models.target import Target
from app.utils import common_utils
from app.utils import file_utils
from app.utils import chart_utils
from app.utils.cvss_utils import calculate_cvss_by_severity


class Reporter(object):
    def __init__(self, target: Target):
        self.target = target

        self.report_root_path = core_app.settings.output_dir

        template_dir = os.path.join(core_app.settings.config_dir, "report_templates")
        self.report_template = os.path.join(template_dir, "base_template.docx")
        self.executive_summary_tpl = os.path.join(
            template_dir, "executive_summary.conf"
        )

        self.target_tmp_dir = os.path.join(
            core_app.settings.local_temp_dir, str(self.target.id)
        )

        self.pie_chart_path = os.path.join(self.target_tmp_dir, "pie_chart.png")
        self.bar_chart_path = os.path.join(self.target_tmp_dir, "bar_chart.png")

        self.document = Document(self.report_template)
        self.records = []
        self.added_alerts = 0

        self.critical_count = 0
        self.high_count = 0
        self.medium_count = 0
        self.low_count = 0
        self.info_count = 0

        # self.alerts_distribution_by_host = {}
        self.overall_cvss_score_by_host = {}
        self.overall_cvss_score = 0

    def run(self):
        # no need of this check here:
        # if self.target.scan_status != ScanStatus.ENUM.RETRIEVED:
        #     core_app.logger.exception("Scan not finished!")
        #     return

        report_generated = False
        try:
            os.makedirs(self.target_tmp_dir, exist_ok=True)

            self.prepare_report()
            self.add_executive_summary()

            if self.target.is_ip_range():
                self.multiple_ips_report()
            else:
                self.single_target_report()

            output_dir = os.path.join(
                self.report_root_path,
                self.target.customer_username,
                str(self.target.id),
            )
            os.makedirs(output_dir, exist_ok=True)
            output_path = os.path.join(output_dir, "report.docx")
            self.document.core_properties.author = "ShieldsUP"
            self.document.core_properties.comments = "Generated By ShieldsUP"
            self.document.save(output_path)
            self.adjust_cover_page(output_path)

            report_generated = True

        finally:
            with MainDatabase() as db:
                if report_generated:
                    core_app.logger.info(
                        f"Report generated successfully for target: {self.target.id}"
                    )
                    crud_target = CrudTarget(db)
                    self.target.scan_status = ScanStatus.ENUM.REPORT_GENERATED
                    self.target.overall_cvss_score = self.overall_cvss_score
                    self.target.cvss_score_by_host = self.overall_cvss_score_by_host
                    crud_target.mark_as_completed(self.target)
                else:
                    core_app.logger.error(
                        f"Failed to generate report for target: {self.target.id}"
                    )
                    crud_target = CrudTarget(db)
                    self.target.scan_status = ScanStatus.ENUM.SCAN_FAILED
                    crud_target.update_scan_status(target=self.target)

            if os.path.exists(self.target_tmp_dir):
                rmtree(self.target_tmp_dir)

    def calculate_severities(self):
        if not self.records:
            return 0

        cvss_distro_by_host = {}
        overall_cvss_distro = {}

        is_ip_range = self.target.is_ip_range()
        for record in self.records:
            severity = record.get("severity")

            if is_ip_range:
                host = record.get("ip")
            else:
                host = "single"

            if not host:
                continue

            if severity:
                if severity == SeverityIndex.ENUM.CRITICAL:
                    self.critical_count += 1
                elif severity == SeverityIndex.ENUM.HIGH:
                    self.high_count += 1
                elif severity == SeverityIndex.ENUM.MEDIUM:
                    self.medium_count += 1
                elif severity == SeverityIndex.ENUM.LOW:
                    self.low_count += 1
                else:
                    self.info_count += 1

            cvss_distro = cvss_distro_by_host.get(host, {})
            cvss_score = None
            try:
                cvss_score = float(record["classification"]["cvss_score"])
            except Exception:
                pass

            if not cvss_score:
                cvss_score = calculate_cvss_by_severity(severity)

            if not cvss_score:
                continue

            if cvss_score >= 0 and cvss_score <= 3.9:
                cvss_low = cvss_distro.get("low", [])
                cvss_low.append(cvss_score)
                cvss_distro["low"] = cvss_low

                overall_cvss_low = overall_cvss_distro.get("low", [])
                overall_cvss_low.append(cvss_score)
                overall_cvss_distro["low"] = overall_cvss_low
            elif cvss_score >= 4.0 and cvss_score <= 6.9:
                cvss_medium = cvss_distro.get("medium", [])
                cvss_medium.append(cvss_score)
                cvss_distro["medium"] = cvss_medium

                overall_cvss_medium = overall_cvss_distro.get("medium", [])
                overall_cvss_medium.append(cvss_score)
                overall_cvss_distro["medium"] = overall_cvss_medium
            elif cvss_score >= 7.0 and cvss_score <= 8.9:
                cvss_high = cvss_distro.get("high", [])
                cvss_high.append(cvss_score)
                cvss_distro["high"] = cvss_high

                overall_cvss_high = overall_cvss_distro.get("high", [])
                overall_cvss_high.append(cvss_score)
                overall_cvss_distro["high"] = overall_cvss_high
            elif cvss_score >= 9.0 and cvss_score <= 10.0:
                cvss_critical = cvss_distro.get("critical", [])
                cvss_critical.append(cvss_score)
                cvss_distro["critical"] = cvss_critical

                overall_cvss_critical = overall_cvss_distro.get("critical", [])
                overall_cvss_critical.append(cvss_score)
                overall_cvss_distro["critical"] = overall_cvss_critical

            # update the cvss distribution by host
            if cvss_distro:
                cvss_distro_by_host[host] = cvss_distro

        # self.overall_cvss_score = total_score / cvss_total_entries
        # self.overall_cvss_score = round(self.overall_cvss_score, 1)

        # calculate overall score by host
        if cvss_distro_by_host:
            for host, entries in cvss_distro_by_host.items():
                critical_range = entries.get("critical", [])
                high_range = entries.get("high", [])
                medium_range = entries.get("medium", [])
                low_range = entries.get("low", [])

                overall_by_host = 0.0

                if critical_range:
                    overall_by_host = statistics.median(critical_range)
                elif high_range:
                    overall_by_host = statistics.median(high_range)
                elif medium_range:
                    overall_by_host = statistics.median(medium_range)
                else:
                    overall_by_host = statistics.median(low_range)
                overall_by_host = round(overall_by_host, 1)
                self.overall_cvss_score_by_host[host] = overall_by_host

        if overall_cvss_distro:
            critical_range = overall_cvss_distro.get("critical", [])
            high_range = overall_cvss_distro.get("high", [])
            medium_range = overall_cvss_distro.get("medium", [])
            low_range = overall_cvss_distro.get("low", [])

            if critical_range:
                self.overall_cvss_score = statistics.median(critical_range)
            elif high_range:
                self.overall_cvss_score = statistics.median(high_range)
            elif medium_range:
                self.overall_cvss_score = statistics.median(medium_range)
            else:
                self.overall_cvss_score = statistics.median(low_range)
            self.overall_cvss_score = round(self.overall_cvss_score, 1)

    def prepare_report(self):
        self.target.scan_completed_time = datetime.now()

        with MainDatabase() as db:
            crud_result = CrudScanResult(db)
            self.records = crud_result.get_list_by_target(self.target)

        self.calculate_severities()
        for _ in range(8):
            self.document.add_paragraph()

        # section = self.document.sections[0]
        # header = section.header
        # header_paragraph = header.paragraphs[0]
        # header_paragraph.text = "ShieldsUP"

        self.fill_place_holder()

        # if not self.records:
        #     # if no records, here itself we can save the report
        #     self.document.add_paragraph()
        #     self.document.add_paragraph("\tNo vulnerabilities were found").bold = True
        #     self.document.add_page_break()

    def add_alert(self, alert):
        try:
            alert_index = self.added_alerts + 1
            title = alert.get("vulnerability_title")
            if not title:
                return

            description = alert.get("vulnerability_description")
            if not description:
                return

            description = description.strip("\n")
            severity = alert["severity"]

            severity_text = alert["severity_text"]

            remediation = alert.get("remediation")
            reference = alert.get("reference")
            classification = alert.get("classification", {})
            cves = classification.get("cve_id")
            cvss_score = classification.get("cvss_score")
            cvss_metrics = classification.get("cvss_metrics")
            matched_at = alert.get("matched_at")
            curl_command = alert.get("curl_command")

            self.document.add_page_break()
            self.document.add_paragraph()
            self.document.add_heading(f"{alert_index}. {title}", level=2)
            self.document.add_paragraph()

            severity_text = severity_text.capitalize()
            h1 = self.document.add_heading("Severity\t\t:    ", level=2)
            # Color based on Severity Level
            r = h1.add_run(severity_text)
            if severity == SeverityIndex.ENUM.CRITICAL:
                r.font.color.rgb = RGBColor(254, 0, 0)
            elif severity == SeverityIndex.ENUM.HIGH:
                r.font.color.rgb = RGBColor(234, 117, 0)
            elif severity == SeverityIndex.ENUM.MEDIUM:
                r.font.color.rgb = RGBColor(255, 153, 0)
            elif severity == SeverityIndex.ENUM.LOW:
                r.font.color.rgb = RGBColor(0, 0, 204)
            else:
                r.font.color.rgb = RGBColor(0, 102, 0)

            if cvss_score:
                cvss_para = self.document.add_heading("CVSS Score\t\t:    ", level=2)
                cvss_para.add_run(f"{cvss_score}")

            evidence = alert.get("evidence", "")

            if evidence:
                evidence = evidence.strip("\n")
                description += "\n\n" + "Evidence: \n" + evidence

            if matched_at:
                description += "\n\n"
                description += "Evidence found at: \n" + matched_at

            if description:
                self.document.add_heading("Details \t\t:", level=2)
                self.document.add_paragraph(description)

            if curl_command:
                self.document.add_heading("Curl Command \t:", level=2)
                self.document.add_paragraph(f"{curl_command}")

            if cves:
                if len(cves) > 1:
                    self.document.add_heading("CVEs \t\t\t:", level=2)
                    cves_str = ""
                    for cve in cves:
                        cves_str += common_utils.smart_str(cve).upper() + "\n"
                    self.document.add_paragraph(cves_str)
                else:
                    cve = common_utils.smart_str(cves[0]).upper()
                    cve_para = self.document.add_heading("CVE \t\t:    ", level=2)
                    cve_para.add_run(f"{cve}")

            if cvss_metrics:
                self.document.add_heading("CVSS Metrics\t\t:", level=2)
                self.document.add_paragraph(f"{cvss_metrics}")

            if not remediation and severity != SeverityIndex.ENUM.INFO:
                remediation = (
                    "For vulnerabilities related to external software "
                    "or third-party components,"
                    " it is advisable to reach out to the respective software vendor. "
                    "In such cases, apply the patches or updates provided by the vendor"
                    " to effectively remediate the vulnerability."
                )
                remediation += "\n\n"
                remediation += (
                    "For vulnerabilities related to the application code, "
                    "it is advisable to reach out to the application developer."
                    " In such cases, apply the patches or updates provided by"
                    " the developer to effectively remediate the vulnerability."
                )

            if remediation:
                self.document.add_heading("Remediation\t\t:", level=2)
                self.document.add_paragraph(remediation)

            if reference:
                self.document.add_heading("Reference\t\t:", level=2)
                reference_str = ""
                for ref in reference:
                    reference_str += ref + "\n"
                self.document.add_paragraph(reference_str)

            self.added_alerts += 1
        except Exception as e:
            core_app.logger.exception(e)

    def single_target_report(self):
        if not self.records:
            return
        for alert in self.records:
            self.add_alert(alert)

    def multiple_ips_report(self):
        core_app.logger.info("Multi IPs report")

        organized_alerts = self.organize_alerts_by_host()
        if not organized_alerts:
            return

        for host, alerts in organized_alerts.items():
            self.document.add_page_break()
            host_cvss_score = self.overall_cvss_score_by_host.get(host, 0.0)

            for _ in range(10):
                self.document.add_paragraph()

            host_table = self.document.add_table(rows=2, cols=2)
            host_table.style = "Medium Shading 1 Accent 5"
            host_table.autofit = True

            row_1 = host_table.rows[0].cells
            # font color white and increase font size to 14pt
            f1 = row_1[0].paragraphs[0].add_run("Vulnerabilities for host")
            f1.font.color.rgb = RGBColor(255, 255, 255)
            f1.font.size = Pt(14)

            f2 = row_1[1].paragraphs[0].add_run(host)
            f2.font.color.rgb = RGBColor(255, 255, 255)
            f2.font.size = Pt(14)

            row_2 = host_table.rows[1].cells

            f3 = row_2[0].paragraphs[0].add_run("Overall CVSS Score for this host")
            f3.font.color.rgb = RGBColor(0, 0, 0)
            f3.font.size = Pt(14)

            f4 = row_2[1].paragraphs[0].add_run(str(host_cvss_score))
            f4.font.color.rgb = RGBColor(0, 0, 0)
            f4.font.size = Pt(14)

            for alert in alerts:
                self.add_alert(alert)

    def create_chart(self):
        """
        Add a pie & bar chart to the report
        """
        try:
            # Remove the old charts
            if os.path.exists(self.pie_chart_path):
                os.remove(self.pie_chart_path)
            if os.path.exists(self.bar_chart_path):
                os.remove(self.bar_chart_path)

            alerts_distribution = OrderedDict(
                {
                    "Critical": self.critical_count,
                    "High": self.high_count,
                    "Medium": self.medium_count,
                    "Low": self.low_count,
                    # "Info": self.info_count,
                }
            )

            if (
                self.critical_count > 0
                or self.high_count > 0
                or self.medium_count > 0
                or self.low_count > 0
            ):
                # Create Pie chart only, if vulnerability exists
                chart_utils.create_chart(
                    alerts_distribution, self.pie_chart_path, chart_type="donut"
                )
                chart_utils.create_chart(
                    alerts_distribution, self.bar_chart_path, chart_type="bar"
                )

        except Exception as ex:
            core_app.logger.exception(ex)

    def organize_alerts_by_host(self) -> dict | None:
        if not self.records:
            return None

        organized_alerts = {}

        for record in self.records:
            host = record.get("ip")
            if not host:
                continue

            alerts = organized_alerts.get(host, [])
            alerts.append(record)

            organized_alerts[host] = alerts

        organized_alerts = dict(sorted(organized_alerts.items()))

        return organized_alerts

    def add_executive_summary(self):
        """
        Function that adds executive summary to the report document
        :return:
        """
        executive_summary_template = ConfigParser()
        executive_summary_template.read(self.executive_summary_tpl)
        summary = executive_summary_template.get("EXECUTIVE_SUMMARY", "summary")
        customer_name = "Customer"
        if customer_name:
            summary = summary.replace(
                "[CUSTOMER]", common_utils.smart_str(customer_name)
            )
        else:
            summary = summary.replace("[CUSTOMER]", "")
        summary = summary.replace(
            "[TARGET]", common_utils.smart_str(self.target.target_address)
        )

        es1 = self.document.add_heading("Executive Summary", 0)
        es1.paragraph_format.page_break_before = True
        self.document.add_paragraph(summary)

        if self.critical_count > 0 or self.high_count > 0:
            risk_level = "High"
        elif self.medium_count > 0:
            risk_level = "Medium"
        elif self.low_count > 0:
            risk_level = "Low"
        else:
            risk_level = "None"

        self.create_chart()

        if risk_level == "None":
            key_points = executive_summary_template.get(
                "EXECUTIVE_SUMMARY", risk_level + "_key_points"
            )
        else:
            key_points = executive_summary_template.get(
                "EXECUTIVE_SUMMARY", risk_level + "_key_points"
            )

        self.document.add_paragraph("")
        self.document.add_heading("Key Points: ", level=2)
        self.document.add_paragraph("\t" + common_utils.smart_str(key_points))

        if os.path.exists(self.pie_chart_path):  # Add Pie Chart
            self.document.add_paragraph("")
            p1 = self.document.add_paragraph()
            p1.add_run().add_picture(
                self.pie_chart_path, width=Inches(4.56), height=Inches(3.30)
            )
            p1.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER  # type: ignore

        if risk_level == "None":
            over_all_risk = executive_summary_template.get(
                "EXECUTIVE_SUMMARY", "None_over_all_risk"
            )
        else:
            over_all_risk = executive_summary_template.get(
                "EXECUTIVE_SUMMARY", "over_all_risk"
            )
            over_all_risk = over_all_risk.replace("[OVER_ALL_RISK]", risk_level)

        self.document.add_paragraph("")

        or1 = self.document.add_heading("Overall Risk: ", level=2)
        if os.path.exists(self.pie_chart_path):
            or1.paragraph_format.page_break_before = True

        self.document.add_paragraph("\t" + over_all_risk)

        if os.path.exists(self.bar_chart_path):  # Add Bar Chart
            self.document.add_paragraph("")
            p2 = self.document.add_paragraph()
            p2.add_run().add_picture(
                self.bar_chart_path, width=Inches(5.2), height=Inches(3.2)
            )
            p2.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER  # type: ignore

        recommendation_section = None
        if not self.records or not self.overall_cvss_score:
            # If there is no alerts, then go for none recommendation
            recommendation_section = "NoActionNeeded_recommendation"
        elif self.overall_cvss_score >= 9.0:
            recommendation_section = "CriticalCVSS_Recommendation"
        elif self.overall_cvss_score >= 7.0:
            recommendation_section = "HighCVSS_Recommendation"
        elif self.overall_cvss_score >= 4.0:
            recommendation_section = "MediumCVSS_Recommendation"
        elif self.overall_cvss_score >= 0.0:
            recommendation_section = "LowCVSS_Recommendation"

        if recommendation_section:
            recommendation = executive_summary_template.get(
                "EXECUTIVE_SUMMARY", recommendation_section
            )

            self.document.add_paragraph("")
            self.document.add_heading("Recommendations: ", level=2)
            self.document.add_paragraph("\t" + common_utils.smart_str(recommendation))

    def fill_place_holder(self):
        """
        Function that fills the place holder in the report document
        :return:
        """
        target_address_for_doc = saxutils.escape(
            common_utils.smart_str(self.target.target_address)
        )
        for paragraph in self.document.paragraphs:
            for run in paragraph.runs:
                if run.text == "PH_TARGET_ADDRESS":
                    run.text = target_address_for_doc
                elif run.text == "PH_STARTED_TIME":
                    run.text = self.target.get_scan_started_time()
                elif run.text == "PH_COMPLETED_TIME":
                    run.text = self.target.get_scan_completed_time()
                elif run.text == "PH_OVERALL_CVSS":
                    run.text = str(self.overall_cvss_score)

    def adjust_cover_page(self, file_name):
        # Temporary Folder for extracting docx files
        target_tmp_dir = os.path.join(
            core_app.settings.local_temp_dir, str(self.target.id)
        )
        report_temp_dir = os.path.join(target_tmp_dir, "temp_report")

        with zipfile.ZipFile(file_name, "r") as z:
            z.extractall(report_temp_dir)  # Extracting into Temporary directory

        if len(self.target.target_address) > 50:
            # When the target address is longer, then increase background image size
            number_of_lines = len(self.target.target_address) / 50
            number_of_lines += 2
            background_image_height = ceil(3190875 + (number_of_lines * 157780))
            file_utils.replace_str_in_file(
                os.path.join(report_temp_dir, "word", "document.xml"),
                'cy="3190875"',
                'cy="' + str(background_image_height) + '"',
            )

        make_archive(
            os.path.join(target_tmp_dir, "tmp_doc"), "zip", report_temp_dir
        )  # Create Zip of Temporary Directory
        os.remove(file_name)  # Remove Old Docx file
        rmtree(report_temp_dir)
        # move the newely generated Docx to the original location
        move(os.path.join(target_tmp_dir, "tmp_doc.zip"), file_name)


def run_reporter(target_id: ObjectId):
    with MainDatabase() as db:
        crud_target = CrudTarget(db)
        target = crud_target.find_by_id(target_id=target_id)

    if not target:
        raise Exception("Unable to find the target with object id {}".format(target_id))

    core_app.logger.info(
        "Scanning IP:"
        + target.target_address
        + " | Customer:"
        + target.customer_username
    )
    reporter = Reporter(target=target)
    reporter.run()
